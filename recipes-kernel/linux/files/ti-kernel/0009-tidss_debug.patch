From f96a02a210e207ebf9ad13ffcc625f4471934667 Mon Sep 17 00:00:00 2001
From: chao zeng <chao.zeng@siemens.com>
Date: Thu, 31 Dec 2020 10:09:47 +0800
Subject: [PATCH 9/9] tidss_debug Signed-off-by: chao zeng
 <chao.zeng@siemens.com>

---
 drivers/gpu/drm/tidss/Kconfig             |  15 -
 drivers/gpu/drm/tidss/Makefile            |   2 -
 drivers/gpu/drm/tidss/tidss_crtc.c        |  21 +-
 drivers/gpu/drm/tidss/tidss_crtc.h        |   2 +-
 drivers/gpu/drm/tidss/tidss_dispc.c       | 762 ++--------------------
 drivers/gpu/drm/tidss/tidss_dispc.h       |  17 +-
 drivers/gpu/drm/tidss/tidss_dispc_regs.h  |  69 +-
 drivers/gpu/drm/tidss/tidss_drv.c         |  45 +-
 drivers/gpu/drm/tidss/tidss_drv.h         |  24 +-
 drivers/gpu/drm/tidss/tidss_encoder.c     |   6 +-
 drivers/gpu/drm/tidss/tidss_encoder.h     |   2 +-
 drivers/gpu/drm/tidss/tidss_irq.c         |  20 +-
 drivers/gpu/drm/tidss/tidss_irq.h         |  15 +-
 drivers/gpu/drm/tidss/tidss_kms.c         |  49 +-
 drivers/gpu/drm/tidss/tidss_kms.h         |   3 +-
 drivers/gpu/drm/tidss/tidss_plane.c       |  54 +-
 drivers/gpu/drm/tidss/tidss_plane.h       |   6 +-
 drivers/gpu/drm/tidss/tidss_scale_coefs.c |   4 +-
 drivers/gpu/drm/tidss/tidss_scale_coefs.h |   2 +-
 drivers/gpu/drm/tidss/tidss_wb.c          | 166 -----
 drivers/gpu/drm/tidss/tidss_wb.h          | 191 ------
 drivers/gpu/drm/tidss/tidss_wb_m2m.c      |   2 +-
 22 files changed, 118 insertions(+), 1359 deletions(-)
 delete mode 100644 drivers/gpu/drm/tidss/tidss_wb.c
 delete mode 100644 drivers/gpu/drm/tidss/tidss_wb.h

diff --git a/drivers/gpu/drm/tidss/Kconfig b/drivers/gpu/drm/tidss/Kconfig
index cf702c1223f6..f790a5215302 100644
--- a/drivers/gpu/drm/tidss/Kconfig
+++ b/drivers/gpu/drm/tidss/Kconfig
@@ -12,18 +12,3 @@ config DRM_TIDSS
 	  of it. The SoCs are 66AK2Gx, AM65x, and J721E. Set this to Y
 	  or M to add display support for TI Keystone family
 	  platforms.
-
-if DRM_TIDSS
-
-config DRM_TIDSS_WB
-	bool "Enable writeback support for TIDSS DRM driver"
-	depends on DRM_TIDSS
-	depends on (VIDEO_V4L2 = y) || (VIDEO_V4L2 = m && DRM_TIDSS = m)
-	depends on VIDEO_DEV && HAS_DMA
-	select VIDEOBUF2_DMA_CONTIG
-	select V4L2_MEM2MEM_DEV
-	default y
-	help
-		Select this to enable memory-to-memory writeback support.
-
-endif
diff --git a/drivers/gpu/drm/tidss/Makefile b/drivers/gpu/drm/tidss/Makefile
index b4c2a6ca5662..312645271014 100644
--- a/drivers/gpu/drm/tidss/Makefile
+++ b/drivers/gpu/drm/tidss/Makefile
@@ -9,6 +9,4 @@ tidss-y := tidss_crtc.o \
 	tidss_scale_coefs.o \
 	tidss_dispc.o
 
-tidss-$(CONFIG_DRM_TIDSS_WB) += tidss_wb.o tidss_wb_m2m.o
-
 obj-$(CONFIG_DRM_TIDSS) += tidss.o
diff --git a/drivers/gpu/drm/tidss/tidss_crtc.c b/drivers/gpu/drm/tidss/tidss_crtc.c
index 3221a707e073..3c5744a91d4a 100644
--- a/drivers/gpu/drm/tidss/tidss_crtc.c
+++ b/drivers/gpu/drm/tidss/tidss_crtc.c
@@ -1,6 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2018 Texas Instruments Incorporated - https://www.ti.com/
  * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  */
 
@@ -24,7 +24,7 @@
 static void tidss_crtc_finish_page_flip(struct tidss_crtc *tcrtc)
 {
 	struct drm_device *ddev = tcrtc->crtc.dev;
-	struct tidss_device *tidss = ddev->dev_private;
+	struct tidss_device *tidss = to_tidss(ddev);
 	struct drm_pending_vblank_event *event;
 	unsigned long flags;
 	bool busy;
@@ -88,7 +88,7 @@ static int tidss_crtc_atomic_check(struct drm_crtc *crtc,
 				   struct drm_crtc_state *state)
 {
 	struct drm_device *ddev = crtc->dev;
-	struct tidss_device *tidss = ddev->dev_private;
+	struct tidss_device *tidss = to_tidss(ddev);
 	struct dispc_device *dispc = tidss->dispc;
 	struct tidss_crtc *tcrtc = to_tidss_crtc(crtc);
 	u32 hw_videoport = tcrtc->hw_videoport;
@@ -165,7 +165,7 @@ static void tidss_crtc_atomic_flush(struct drm_crtc *crtc,
 {
 	struct tidss_crtc *tcrtc = to_tidss_crtc(crtc);
 	struct drm_device *ddev = crtc->dev;
-	struct tidss_device *tidss = ddev->dev_private;
+	struct tidss_device *tidss = to_tidss(ddev);
 	unsigned long flags;
 
 	dev_dbg(ddev->dev,
@@ -216,7 +216,7 @@ static void tidss_crtc_atomic_enable(struct drm_crtc *crtc,
 {
 	struct tidss_crtc *tcrtc = to_tidss_crtc(crtc);
 	struct drm_device *ddev = crtc->dev;
-	struct tidss_device *tidss = ddev->dev_private;
+	struct tidss_device *tidss = to_tidss(ddev);
 	const struct drm_display_mode *mode = &crtc->state->adjusted_mode;
 	unsigned long flags;
 	int r;
@@ -259,7 +259,7 @@ static void tidss_crtc_atomic_disable(struct drm_crtc *crtc,
 {
 	struct tidss_crtc *tcrtc = to_tidss_crtc(crtc);
 	struct drm_device *ddev = crtc->dev;
-	struct tidss_device *tidss = ddev->dev_private;
+	struct tidss_device *tidss = to_tidss(ddev);
 	unsigned long flags;
 
 	dev_dbg(ddev->dev, "%s, event %p\n", __func__, crtc->state->event);
@@ -295,7 +295,7 @@ enum drm_mode_status tidss_crtc_mode_valid(struct drm_crtc *crtc,
 {
 	struct tidss_crtc *tcrtc = to_tidss_crtc(crtc);
 	struct drm_device *ddev = crtc->dev;
-	struct tidss_device *tidss = ddev->dev_private;
+	struct tidss_device *tidss = to_tidss(ddev);
 
 	return dispc_vp_mode_valid(tidss->dispc, tcrtc->hw_videoport, mode);
 }
@@ -314,7 +314,7 @@ static const struct drm_crtc_helper_funcs tidss_crtc_helper_funcs = {
 static int tidss_crtc_enable_vblank(struct drm_crtc *crtc)
 {
 	struct drm_device *ddev = crtc->dev;
-	struct tidss_device *tidss = ddev->dev_private;
+	struct tidss_device *tidss = to_tidss(ddev);
 
 	dev_dbg(ddev->dev, "%s\n", __func__);
 
@@ -328,7 +328,7 @@ static int tidss_crtc_enable_vblank(struct drm_crtc *crtc)
 static void tidss_crtc_disable_vblank(struct drm_crtc *crtc)
 {
 	struct drm_device *ddev = crtc->dev;
-	struct tidss_device *tidss = ddev->dev_private;
+	struct tidss_device *tidss = to_tidss(ddev);
 
 	dev_dbg(ddev->dev, "%s\n", __func__);
 
@@ -352,8 +352,7 @@ static void tidss_crtc_reset(struct drm_crtc *crtc)
 		return;
 	}
 
-	crtc->state = &tcrtc->base;
-	crtc->state->crtc = crtc;
+	__drm_atomic_helper_crtc_reset(crtc, &tcrtc->base);
 }
 
 static struct drm_crtc_state *tidss_crtc_duplicate_state(struct drm_crtc *crtc)
diff --git a/drivers/gpu/drm/tidss/tidss_crtc.h b/drivers/gpu/drm/tidss/tidss_crtc.h
index 09e773666228..040d1205496b 100644
--- a/drivers/gpu/drm/tidss/tidss_crtc.h
+++ b/drivers/gpu/drm/tidss/tidss_crtc.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2018 Texas Instruments Incorporated - https://www.ti.com/
  * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  */
 
diff --git a/drivers/gpu/drm/tidss/tidss_dispc.c b/drivers/gpu/drm/tidss/tidss_dispc.c
index 05807354a8b4..305225a46fd3 100644
--- a/drivers/gpu/drm/tidss/tidss_dispc.c
+++ b/drivers/gpu/drm/tidss/tidss_dispc.c
@@ -1,9 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2016-2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2016-2018 Texas Instruments Incorporated - https://www.ti.com/
  * Author: Jyri Sarha <jsarha@ti.com>
  */
-
+#define DEBUG 1
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/dma-mapping.h>
@@ -19,6 +19,7 @@
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
+#include <linux/sys_soc.h>
 
 #include <drm/drm_fourcc.h>
 #include <drm/drm_fb_cma_helper.h>
@@ -269,8 +270,6 @@ const struct dispc_features dispc_j721e_feats = {
 	.vid_name = { "vid1", "vidl1", "vid2", "vidl2" },
 	.vid_lite = { 0, 1, 0, 1, },
 	.vid_order = { 1, 3, 0, 2 },
-	.has_writeback = true,
-	.wb_name = "wb",
 };
 
 static const u16 *dispc_common_regmap;
@@ -287,15 +286,12 @@ struct dispc_device {
 	void __iomem *base_vid[TIDSS_MAX_PLANES];
 	void __iomem *base_ovr[TIDSS_MAX_PORTS];
 	void __iomem *base_vp[TIDSS_MAX_PORTS];
-	void __iomem *base_wb;
 
 	struct regmap *oldi_io_ctrl;
 
 	struct clk *vp_clk[TIDSS_MAX_PORTS];
 
 	const struct dispc_features *feat;
-	u32 wb_reserved_ovr;
-	bool wb_managed;
 
 	struct clk *fclk;
 
@@ -307,6 +303,8 @@ struct dispc_device {
 	u32 num_fourccs;
 
 	u32 memory_bandwidth_limit;
+
+	struct dispc_errata errata;
 };
 
 static void dispc_write(struct dispc_device *dispc, u16 reg, u32 val)
@@ -334,20 +332,6 @@ static u32 dispc_vid_read(struct dispc_device *dispc, u32 hw_plane, u16 reg)
 	return ioread32(base + reg);
 }
 
-static void dispc_wb_write(struct dispc_device *dispc, u16 reg, u32 val)
-{
-	void __iomem *base = dispc->base_wb;
-
-	iowrite32(val, base + reg);
-}
-
-static u32 dispc_wb_read(struct dispc_device *dispc, u16 reg)
-{
-	void __iomem *base = dispc->base_wb;
-
-	return ioread32(base + reg);
-}
-
 static void dispc_ovr_write(struct dispc_device *dispc, u32 hw_videoport,
 			    u16 reg, u32 val)
 {
@@ -429,20 +413,6 @@ static void VID_REG_FLD_MOD(struct dispc_device *dispc, u32 hw_plane, u32 idx,
 				val, start, end));
 }
 
-static u32 WB_REG_GET(struct dispc_device *dispc, u32 idx,
-		      u32 start, u32 end)
-{
-	return FLD_GET(dispc_wb_read(dispc, idx), start, end);
-}
-
-static void WB_REG_FLD_MOD(struct dispc_device *dispc, u32 idx,
-			   u32 val, u32 start, u32 end)
-{
-	dispc_wb_write(dispc, idx,
-		       FLD_MOD(dispc_wb_read(dispc, idx),
-			       val, start, end));
-}
-
 static u32 VP_REG_GET(struct dispc_device *dispc, u32 vp, u32 idx,
 		      u32 start, u32 end)
 {
@@ -523,42 +493,6 @@ static u32 dispc_vid_irq_to_raw(dispc_irq_t vidstat, u32 hw_plane)
 	return stat;
 }
 
-static dispc_irq_t dispc_wb_irq_from_raw(u32 stat)
-{
-	dispc_irq_t wbstat = 0;
-
-	if (stat & BIT(0))
-		wbstat |= DSS_IRQ_DEVICE_WBBUFFEROVERFLOW;
-	if (stat & BIT(1))
-		wbstat |= DSS_IRQ_DEVICE_WBUNCOMPLETEERROR;
-	if (stat & BIT(2))
-		wbstat |= DSS_IRQ_DEVICE_FRAMEDONEWB;
-	if (stat & BIT(3))
-		wbstat |= DSS_IRQ_DEVICE_WBSECURITYVIOLATION;
-	if (stat & BIT(4))
-		wbstat |= DSS_IRQ_DEVICE_WBSYNC;
-
-	return wbstat;
-}
-
-static u32 dispc_wb_irq_to_raw(dispc_irq_t wbstat)
-{
-	u32 stat = 0;
-
-	if (wbstat & DSS_IRQ_DEVICE_WBBUFFEROVERFLOW)
-		stat |= BIT(0);
-	if (wbstat & DSS_IRQ_DEVICE_WBUNCOMPLETEERROR)
-		stat |= BIT(1);
-	if (wbstat & DSS_IRQ_DEVICE_FRAMEDONEWB)
-		stat |= BIT(2);
-	if (wbstat & DSS_IRQ_DEVICE_WBSECURITYVIOLATION)
-		stat |= BIT(3);
-	if (wbstat & DSS_IRQ_DEVICE_WBSYNC)
-		stat |= BIT(4);
-
-	return stat;
-}
-
 static dispc_irq_t dispc_k2g_vp_read_irqstatus(struct dispc_device *dispc,
 					       u32 hw_videoport)
 {
@@ -706,21 +640,6 @@ static void dispc_k3_vid_write_irqstatus(struct dispc_device *dispc,
 	dispc_write(dispc, DISPC_VID_IRQSTATUS(hw_plane), stat);
 }
 
-static dispc_irq_t dispc_k3_wb_read_irqstatus(struct dispc_device *dispc)
-{
-	u32 stat = dispc_read(dispc, WB_IRQSTATUS);
-
-	return dispc_wb_irq_from_raw(stat);
-}
-
-static void dispc_k3_wb_write_irqstatus(struct dispc_device *dispc,
-					dispc_irq_t wbstat)
-{
-	u32 stat = dispc_wb_irq_to_raw(wbstat);
-
-	dispc_write(dispc, WB_IRQSTATUS, stat);
-}
-
 static dispc_irq_t dispc_k3_vp_read_irqenable(struct dispc_device *dispc,
 					      u32 hw_videoport)
 {
@@ -753,21 +672,6 @@ static void dispc_k3_vid_set_irqenable(struct dispc_device *dispc,
 	dispc_write(dispc, DISPC_VID_IRQENABLE(hw_plane), stat);
 }
 
-static dispc_irq_t dispc_k3_wb_read_irqenable(struct dispc_device *dispc)
-{
-	u32 stat = dispc_read(dispc, WB_IRQENABLE);
-
-	return dispc_wb_irq_from_raw(stat);
-}
-
-static void dispc_k3_wb_write_irqenable(struct dispc_device *dispc,
-					dispc_irq_t wbstat)
-{
-	u32 stat = dispc_wb_irq_to_raw(wbstat);
-
-	dispc_write(dispc, WB_IRQENABLE, stat);
-}
-
 static
 void dispc_k3_clear_irqstatus(struct dispc_device *dispc, dispc_irq_t clearmask)
 {
@@ -786,12 +690,6 @@ void dispc_k3_clear_irqstatus(struct dispc_device *dispc, dispc_irq_t clearmask)
 			top_clear |= BIT(4 + i);
 		}
 	}
-	if (dispc_has_writeback(dispc)) {
-		if (clearmask & DSS_IRQ_DEVICE_WB_MASK) {
-			dispc_k3_wb_write_irqstatus(dispc, clearmask);
-			top_clear |= BIT(14);
-		}
-	}
 	if (dispc->feat->subrev == DISPC_K2G)
 		return;
 
@@ -813,9 +711,6 @@ dispc_irq_t dispc_k3_read_and_clear_irqstatus(struct dispc_device *dispc)
 	for (i = 0; i < dispc->feat->num_planes; ++i)
 		status |= dispc_k3_vid_read_irqstatus(dispc, i);
 
-	if (dispc_has_writeback(dispc))
-		status |= dispc_k3_wb_read_irqstatus(dispc);
-
 	dispc_k3_clear_irqstatus(dispc, status);
 
 	return status;
@@ -832,9 +727,6 @@ static dispc_irq_t dispc_k3_read_irqenable(struct dispc_device *dispc)
 	for (i = 0; i < dispc->feat->num_planes; ++i)
 		enable |= dispc_k3_vid_read_irqenable(dispc, i);
 
-	if (dispc_has_writeback(dispc))
-		enable |= dispc_k3_wb_read_irqenable(dispc);
-
 	return enable;
 }
 
@@ -866,14 +758,6 @@ static void dispc_k3_set_irqenable(struct dispc_device *dispc,
 			main_disable |= BIT(i + 4);	/* VID IRQ */
 	}
 
-	if (dispc_has_writeback(dispc)) {
-		dispc_k3_wb_write_irqenable(dispc, mask);
-		if (mask & DSS_IRQ_DEVICE_WB_MASK)
-			main_enable |= BIT(14);		/* WB_IRQ */
-		else
-			main_disable |= BIT(14);	/* WB_IRQ */
-	}
-
 	if (main_enable)
 		dispc_write(dispc, DISPC_IRQENABLE_SET, main_enable);
 
@@ -1116,12 +1000,12 @@ void dispc_vp_enable(struct dispc_device *dispc, u32 hw_videoport,
 
 	ieo = !!(tstate->bus_flags & DRM_BUS_FLAG_DE_LOW);
 
-	ipc = !!(tstate->bus_flags & DRM_BUS_FLAG_PIXDATA_NEGEDGE);
+	ipc = !!(tstate->bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE);
 
 	/* always use the 'rf' setting */
 	onoff = true;
 
-	rf = !!(tstate->bus_flags & DRM_BUS_FLAG_SYNC_POSEDGE);
+	rf = !!(tstate->bus_flags & DRM_BUS_FLAG_SYNC_DRIVE_POSEDGE);
 
 	/* always use aligned syncs */
 	align = true;
@@ -1471,7 +1355,7 @@ void dispc_csc_yuv2rgb_regval(const struct dispc_csc_coef *csc, u32 *regval)
 	dispc_csc_offset_regval(csc, regval);
 }
 
-static
+__maybe_unused static
 void dispc_csc_rgb2yuv_regval(const struct dispc_csc_coef *csc, u32 *regval)
 {
 	regval[0] = CVAL(csc->m[CSC_YR], csc->m[CSC_YG]);
@@ -1539,25 +1423,6 @@ static void dispc_k3_vid_write_csc(struct dispc_device *dispc, u32 hw_plane,
 				regval[i]);
 }
 
-static void dispc_k3_wb_write_csc(struct dispc_device *dispc,
-				  const struct dispc_csc_coef *csc)
-{
-	static const u16 dispc_wb_csc_coef_reg[DISPC_CSC_REGVAL_LEN] = {
-		DISPC_WB_CSC_COEF(0), DISPC_WB_CSC_COEF(1),
-		DISPC_WB_CSC_COEF(2), DISPC_WB_CSC_COEF(3),
-		DISPC_WB_CSC_COEF(4), DISPC_WB_CSC_COEF(5),
-		DISPC_WB_CSC_COEF(6), DISPC_WB_CSC_COEF7,
-	};
-	u32 regval[DISPC_CSC_REGVAL_LEN];
-	unsigned int i;
-
-	csc->to_regval(csc, regval);
-
-	for (i = 0; i < ARRAY_SIZE(dispc_wb_csc_coef_reg); i++)
-		dispc_wb_write(dispc, dispc_wb_csc_coef_reg[i],
-			       regval[i]);
-}
-
 /* YUV -> RGB, ITU-R BT.601, full range */
 static const struct dispc_csc_coef csc_yuv2rgb_bt601_full = {
 	dispc_csc_yuv2rgb_regval,
@@ -1606,61 +1471,11 @@ static const struct dispc_csc_coef csc_yuv2rgb_bt709_lim = {
 	"BT.709 Limited",
 };
 
-/* RGB -> YUV, ITU-R BT.601, full range */
-static const struct dispc_csc_coef csc_rgb2yuv_bt601_full = {
-	dispc_csc_rgb2yuv_regval,
-	{ 77,  150,  29,	/* yr,   yg,  yb | 0.299  0.587  0.114|*/
-	 -43,  -85, 128,	/* cbr, cbg, cbb |-0.173 -0.339  0.511|*/
-	 128, -107, -21 },	/* crr, crg, crb | 0.511 -0.428 -0.083|*/
-	{    0,     0,     0, },
-	{    0,  2048,  2048, },	/* full range */
-	CLIP_FULL_RANGE,
-	"BT.601 Full",
-};
-
-/* RGB -> YUV, ITU-R BT.601, limited range */
-static const struct dispc_csc_coef csc_rgb2yuv_bt601_lim = {
-	dispc_csc_rgb2yuv_regval,
-	{ 66,  129,  25,	/* yr,   yg,  yb | 0.257  0.504  0.098|*/
-	 -38,  -74, 112,	/* cbr, cbg, cbb |-0.148 -0.291  0.439|*/
-	 112,  -94, -18 },	/* crr, crg, crb | 0.439 -0.368 -0.071|*/
-	{    0,     0,     0, },
-	{  256,  2048,  2048, },	/* limited range */
-	CLIP_FULL_RANGE,
-	"BT.601 Limited",
-};
-
-/* RGB -> YUV, ITU-R BT.709, full range */
-static const struct dispc_csc_coef csc_rgb2yuv_bt709_full = {
-	dispc_csc_rgb2yuv_regval,
-	{ 54,  183,  18,	/* yr,   yg,  yb | 0.1826  0.6142  0.0620|*/
-	 -30, -101, 131,	/* cbr, cbg, cbb |-0.1006 -0.3386  0.4392|*/
-	 131, -119, -12, },	/* crr, crg, crb | 0.4392 -0.3989 -0.0403|*/
-	{    0,     0,     0, },
-	{    0,  2048,  2048, },	/* full range */
-	CLIP_FULL_RANGE,
-	"BT.709 Full",
-};
-
-/* RGB -> YUV, ITU-R BT.709, limited range */
-static const struct dispc_csc_coef csc_rgb2yuv_bt709_lim = {
-	dispc_csc_rgb2yuv_regval,
-	{ 47,  157,   16,	/* yr,   yg,  yb | 0.1826  0.6142  0.0620|*/
-	 -26,  -87,  112,	/* cbr, cbg, cbb |-0.1006 -0.3386  0.4392|*/
-	 112, -102,  -10, },	/* crr, crg, crb | 0.4392 -0.3989 -0.0403|*/
-	{    0,     0,     0, },
-	{  256,  2048,  2048, },	/* limited range */
-	CLIP_FULL_RANGE,
-	"BT.709 Limited",
-};
-
-struct dispc_csc_entry {
+static const struct {
 	enum drm_color_encoding encoding;
 	enum drm_color_range range;
 	const struct dispc_csc_coef *csc;
-};
-
-static const struct dispc_csc_entry dispc_yuv2rgb_table[] = {
+} dispc_csc_table[] = {
 	{ DRM_COLOR_YCBCR_BT601, DRM_COLOR_YCBCR_FULL_RANGE,
 	  &csc_yuv2rgb_bt601_full, },
 	{ DRM_COLOR_YCBCR_BT601, DRM_COLOR_YCBCR_LIMITED_RANGE,
@@ -1671,43 +1486,16 @@ static const struct dispc_csc_entry dispc_yuv2rgb_table[] = {
 	  &csc_yuv2rgb_bt709_lim, },
 };
 
-static const struct dispc_csc_entry dispc_rgb2yuv_table[] = {
-	{ DRM_COLOR_YCBCR_BT601, DRM_COLOR_YCBCR_FULL_RANGE,
-	  &csc_rgb2yuv_bt601_full, },
-	{ DRM_COLOR_YCBCR_BT601, DRM_COLOR_YCBCR_LIMITED_RANGE,
-	  &csc_rgb2yuv_bt601_lim, },
-	{ DRM_COLOR_YCBCR_BT709, DRM_COLOR_YCBCR_FULL_RANGE,
-	  &csc_rgb2yuv_bt709_full, },
-	{ DRM_COLOR_YCBCR_BT709, DRM_COLOR_YCBCR_LIMITED_RANGE,
-	  &csc_rgb2yuv_bt709_lim, },
-};
-
-enum dispc_csc_direction {
-	DISPC_YUV2RGB,
-	DISPC_RGB2YUV,
-};
-
 static const
-struct dispc_csc_coef *dispc_find_csc(enum dispc_csc_direction direction,
-				      enum drm_color_encoding encoding,
+struct dispc_csc_coef *dispc_find_csc(enum drm_color_encoding encoding,
 				      enum drm_color_range range)
 {
 	unsigned int i;
-	const struct dispc_csc_entry *csc_table;
-	u32 table_size;
 
-	if (direction == DISPC_YUV2RGB) {
-		csc_table = dispc_yuv2rgb_table;
-		table_size = ARRAY_SIZE(dispc_yuv2rgb_table);
-	} else {
-		csc_table = dispc_rgb2yuv_table;
-		table_size = ARRAY_SIZE(dispc_rgb2yuv_table);
-	}
-
-	for (i = 0; i < table_size; i++) {
-		if (csc_table[i].encoding == encoding &&
-		    csc_table[i].range == range) {
-			return csc_table[i].csc;
+	for (i = 0; i < ARRAY_SIZE(dispc_csc_table); i++) {
+		if (dispc_csc_table[i].encoding == encoding &&
+		    dispc_csc_table[i].range == range) {
+			return dispc_csc_table[i].csc;
 		}
 	}
 	return NULL;
@@ -1718,10 +1506,9 @@ static void dispc_vid_csc_setup(struct dispc_device *dispc, u32 hw_plane,
 {
 	const struct dispc_csc_coef *coef;
 
-	coef = dispc_find_csc(DISPC_YUV2RGB, state->color_encoding,
-			      state->color_range);
+	coef = dispc_find_csc(state->color_encoding, state->color_range);
 	if (!coef) {
-		dev_err(dispc->dev, "%s: YUV2RGB CSC (%u,%u) not found\n",
+		dev_err(dispc->dev, "%s: CSC (%u,%u) not found\n",
 			__func__, state->color_encoding, state->color_range);
 		return;
 	}
@@ -1738,26 +1525,6 @@ static void dispc_vid_csc_enable(struct dispc_device *dispc, u32 hw_plane,
 	VID_REG_FLD_MOD(dispc, hw_plane, DISPC_VID_ATTRIBUTES, !!enable, 9, 9);
 }
 
-static void dispc_wb_csc_setup(struct dispc_device *dispc,
-			       const struct drm_plane_state *state)
-{
-	static const struct dispc_csc_coef *coef;
-
-	coef = dispc_find_csc(DISPC_RGB2YUV, state->color_encoding,
-			      state->color_range);
-	if (!coef) {
-		dev_err(dispc->dev, "%s: RGB2YUV CSC (%u,%u) not found\n",
-			__func__, state->color_encoding, state->color_range);
-		return;
-	}
-	dispc_k3_wb_write_csc(dispc, coef);
-}
-
-static void dispc_wb_csc_enable(struct dispc_device *dispc, bool enable)
-{
-	WB_REG_FLD_MOD(dispc, DISPC_WB_ATTRIBUTES, !!enable, 11, 11);
-}
-
 /* SCALER */
 
 static u32 dispc_calc_fir_inc(u32 in, u32 out)
@@ -1820,60 +1587,6 @@ static void dispc_vid_write_fir_coefs(struct dispc_device *dispc,
 	}
 }
 
-enum dispc_wb_fir_coef_set {
-	DISPC_WB_FIR_COEF_HORIZ,
-	DISPC_WB_FIR_COEF_HORIZ_UV,
-	DISPC_WB_FIR_COEF_VERT,
-	DISPC_WB_FIR_COEF_VERT_UV,
-};
-
-static void dispc_wb_write_fir_coefs(struct dispc_device *dispc,
-				     enum dispc_wb_fir_coef_set coef_set,
-				     const struct tidss_scale_coefs *coefs)
-{
-	static const u16 c0_regs[] = {
-		[DISPC_WB_FIR_COEF_HORIZ] = DISPC_WB_FIR_COEFS_H0,
-		[DISPC_WB_FIR_COEF_HORIZ_UV] = DISPC_WB_FIR_COEFS_H0_C,
-		[DISPC_WB_FIR_COEF_VERT] = DISPC_WB_FIR_COEFS_V0,
-		[DISPC_WB_FIR_COEF_VERT_UV] = DISPC_WB_FIR_COEFS_V0_C,
-	};
-
-	static const u16 c12_regs[] = {
-		[DISPC_WB_FIR_COEF_HORIZ] = DISPC_WB_FIR_COEFS_H12,
-		[DISPC_WB_FIR_COEF_HORIZ_UV] = DISPC_WB_FIR_COEFS_H12_C,
-		[DISPC_WB_FIR_COEF_VERT] = DISPC_WB_FIR_COEFS_V12,
-		[DISPC_WB_FIR_COEF_VERT_UV] = DISPC_WB_FIR_COEFS_V12_C,
-	};
-
-	const u16 c0_base = c0_regs[coef_set];
-	const u16 c12_base = c12_regs[coef_set];
-	int phase;
-
-	if (!coefs) {
-		dev_err(dispc->dev, "%s: No coefficients given.\n", __func__);
-		return;
-	}
-
-	for (phase = 0; phase <= 8; ++phase) {
-		u16 reg = c0_base + phase * 4;
-		u16 c0 = coefs->c0[phase];
-
-		dispc_wb_write(dispc, reg, c0);
-	}
-
-	for (phase = 0; phase <= 15; ++phase) {
-		u16 reg = c12_base + phase * 4;
-		s16 c1, c2;
-		u32 c12;
-
-		c1 = coefs->c1[phase];
-		c2 = coefs->c2[phase];
-		c12 = FLD_VAL(c1, 19, 10) | FLD_VAL(c2, 29, 20);
-
-		dispc_wb_write(dispc, reg, c12);
-	}
-}
-
 static bool dispc_fourcc_is_yuv(u32 fourcc)
 {
 	switch (fourcc) {
@@ -1889,7 +1602,6 @@ static bool dispc_fourcc_is_yuv(u32 fourcc)
 struct dispc_scaling_params {
 	int xinc, yinc;
 	u32 in_w, in_h, in_w_uv, in_h_uv;
-	u32 out_w, out_h, out_w_uv, out_h_uv;
 	u32 fir_xinc, fir_yinc, fir_xinc_uv, fir_yinc_uv;
 	bool scale_x, scale_y;
 	const struct tidss_scale_coefs *xcoef, *ycoef, *xcoef_uv, *ycoef_uv;
@@ -2060,168 +1772,6 @@ static int dispc_vid_calc_scaling(struct dispc_device *dispc,
 	return 0;
 }
 
-static int dispc_wb_calc_scaling(struct dispc_device *dispc,
-				 const struct drm_plane_state *state,
-				 struct dispc_scaling_params *sp)
-{
-	const struct dispc_features_scaling *f = &dispc->feat->scaling;
-	u32 fourcc = state->fb->format->format;
-	u32 in_width_max_5tap = f->in_width_max_5tap_rgb;
-	u32 in_width_max_3tap = f->in_width_max_3tap_rgb;
-	u32 downscale_limit;
-	u32 in_width_max;
-
-	memset(sp, 0, sizeof(*sp));
-	sp->xinc = sp->yinc = 1;
-	sp->in_w = sp->in_w_uv = state->src_w >> 16;
-	sp->in_h = sp->in_h_uv = state->src_h >> 16;
-	sp->out_w = sp->out_w_uv = state->crtc_w;
-	sp->out_h = sp->out_h_uv = state->crtc_h;
-
-	sp->scale_x = sp->in_w != sp->out_w;
-	sp->scale_y = sp->in_h != sp->out_h;
-
-	if (dispc_fourcc_is_yuv(fourcc)) {
-		in_width_max_5tap = f->in_width_max_5tap_yuv;
-		in_width_max_3tap = f->in_width_max_3tap_yuv;
-
-		sp->out_w_uv >>= 1;
-		sp->scale_x = true;
-
-		if (fourcc == DRM_FORMAT_NV12) {
-			sp->out_h_uv >>= 1;
-			sp->scale_y = true;
-		}
-	}
-
-	/* Skip the rest if no scaling is used */
-	if (!sp->scale_x && !sp->scale_y)
-		return 0;
-
-	if (sp->in_w > in_width_max_5tap) {
-		sp->five_taps = false;
-		in_width_max = in_width_max_3tap;
-		downscale_limit = f->downscale_limit_3tap;
-	} else {
-		sp->five_taps = true;
-		in_width_max = in_width_max_5tap;
-		downscale_limit = f->downscale_limit_5tap;
-	}
-
-	if (sp->scale_x) {
-		sp->fir_xinc = dispc_calc_fir_inc(sp->in_w, sp->out_w);
-
-		if (sp->fir_xinc < dispc_calc_fir_inc(1, f->upscale_limit)) {
-			dev_dbg(dispc->dev,
-				"%s: X-scaling factor %u/%u > %u\n",
-				__func__, state->crtc_w, state->src_w >> 16,
-				f->upscale_limit);
-			return -EINVAL;
-		}
-
-		if (sp->fir_xinc >= dispc_calc_fir_inc(downscale_limit, 1)) {
-			sp->xinc = DIV_ROUND_UP(DIV_ROUND_UP(sp->in_w,
-							     sp->out_w),
-						downscale_limit);
-
-			if (sp->xinc > f->xinc_max) {
-				dev_dbg(dispc->dev,
-					"%s: X-scaling factor %u/%u < 1/%u\n",
-					__func__, state->crtc_w,
-					state->src_w >> 16,
-					downscale_limit * f->xinc_max);
-				return -EINVAL;
-			}
-
-			sp->in_w = (state->src_w >> 16) / sp->xinc;
-		}
-
-		while (sp->in_w > in_width_max) {
-			sp->xinc++;
-			sp->in_w = (state->src_w >> 16) / sp->xinc;
-		}
-
-		if (sp->xinc > f->xinc_max) {
-			dev_dbg(dispc->dev,
-				"%s: Too wide input bufer %u > %u\n", __func__,
-				state->src_w >> 16, in_width_max * f->xinc_max);
-			return -EINVAL;
-		}
-
-		/*
-		 * We need even line length for YUV formats. Decimation
-		 * can lead to odd length, so we need to make it even
-		 * again.
-		 */
-		if (dispc_fourcc_is_yuv(fourcc))
-			sp->in_w &= ~1;
-
-		sp->fir_xinc = dispc_calc_fir_inc(sp->in_w, sp->out_w);
-	}
-
-	if (sp->scale_y) {
-		sp->fir_yinc = dispc_calc_fir_inc(sp->in_h, sp->out_h);
-
-		if (sp->fir_yinc < dispc_calc_fir_inc(1, f->upscale_limit)) {
-			dev_dbg(dispc->dev,
-				"%s: Y-scaling factor %u/%u > %u\n",
-				__func__, state->crtc_h, state->src_h >> 16,
-				f->upscale_limit);
-			return -EINVAL;
-		}
-
-		if (sp->fir_yinc >= dispc_calc_fir_inc(downscale_limit, 1)) {
-			sp->yinc = DIV_ROUND_UP(DIV_ROUND_UP(sp->in_h,
-							     sp->out_h),
-						downscale_limit);
-
-			sp->in_h /= sp->yinc;
-			sp->fir_yinc = dispc_calc_fir_inc(sp->in_h,
-							  sp->out_h);
-		}
-	}
-
-	dev_dbg(dispc->dev,
-		"%s: %ux%u decim %ux%u -> %ux%u firinc %u.%03ux%u.%03u taps %u -> %ux%u\n",
-		__func__, state->src_w >> 16, state->src_h >> 16,
-		sp->xinc, sp->yinc, sp->in_w, sp->in_h,
-		sp->fir_xinc / 0x200000u,
-		((sp->fir_xinc & 0x1FFFFFu) * 999u) / 0x1FFFFFu,
-		sp->fir_yinc / 0x200000u,
-		((sp->fir_yinc & 0x1FFFFFu) * 999u) / 0x1FFFFFu,
-		sp->five_taps ? 5 : 3,
-		state->crtc_w, state->crtc_h);
-
-	if (dispc_fourcc_is_yuv(fourcc)) {
-		if (sp->scale_x) {
-			sp->in_w_uv /= sp->xinc;
-			sp->fir_xinc_uv = dispc_calc_fir_inc(sp->in_w_uv,
-							     sp->out_w_uv);
-			sp->xcoef_uv = tidss_get_scale_coefs(dispc->dev,
-							     sp->fir_xinc_uv,
-							     true);
-		}
-		if (sp->scale_y) {
-			sp->in_h_uv /= sp->yinc;
-			sp->fir_yinc_uv = dispc_calc_fir_inc(sp->in_h_uv,
-							     sp->out_h_uv);
-			sp->ycoef_uv = tidss_get_scale_coefs(dispc->dev,
-							     sp->fir_yinc_uv,
-							     sp->five_taps);
-		}
-	}
-
-	if (sp->scale_x)
-		sp->xcoef = tidss_get_scale_coefs(dispc->dev, sp->fir_xinc,
-						  true);
-
-	if (sp->scale_y)
-		sp->ycoef = tidss_get_scale_coefs(dispc->dev, sp->fir_yinc,
-						  sp->five_taps);
-
-	return 0;
-}
-
 static void dispc_vid_set_scaling(struct dispc_device *dispc,
 				  u32 hw_plane,
 				  struct dispc_scaling_params *sp,
@@ -2274,51 +1824,6 @@ static void dispc_vid_set_scaling(struct dispc_device *dispc,
 	}
 }
 
-static void dispc_wb_set_scaling(struct dispc_device *dispc,
-				 struct dispc_scaling_params *sp,
-				 u32 fourcc)
-{
-	/* HORIZONTAL RESIZE ENABLE */
-	WB_REG_FLD_MOD(dispc, DISPC_WB_ATTRIBUTES, sp->scale_x, 7, 7);
-
-	/* VERTICAL RESIZE ENABLE */
-	WB_REG_FLD_MOD(dispc, DISPC_WB_ATTRIBUTES, sp->scale_y, 8, 8);
-
-	/* Skip the rest if no scaling is used */
-	if (!sp->scale_x && !sp->scale_y)
-		return;
-
-	/* VERTICAL 5-TAPS  */
-	WB_REG_FLD_MOD(dispc, DISPC_WB_ATTRIBUTES, sp->five_taps, 21, 21);
-
-	if (dispc_fourcc_is_yuv(fourcc)) {
-		if (sp->scale_x) {
-			dispc_wb_write(dispc, DISPC_WB_FIRH2, sp->fir_xinc_uv);
-			dispc_wb_write_fir_coefs(dispc,
-						  DISPC_WB_FIR_COEF_HORIZ_UV,
-						  sp->xcoef_uv);
-		}
-		if (sp->scale_y) {
-			dispc_wb_write(dispc, DISPC_WB_FIRV2, sp->fir_yinc_uv);
-			dispc_wb_write_fir_coefs(dispc,
-						 DISPC_WB_FIR_COEF_VERT_UV,
-						 sp->ycoef_uv);
-		}
-	}
-
-	if (sp->scale_x) {
-		dispc_wb_write(dispc, DISPC_WB_FIRH, sp->fir_xinc);
-		dispc_wb_write_fir_coefs(dispc, DISPC_WB_FIR_COEF_HORIZ,
-					 sp->xcoef);
-	}
-
-	if (sp->scale_y) {
-		dispc_wb_write(dispc, DISPC_WB_FIRV, sp->fir_yinc);
-		dispc_wb_write_fir_coefs(dispc, DISPC_WB_FIR_COEF_VERT,
-					 sp->ycoef);
-	}
-}
-
 /* OTHER */
 
 static const struct {
@@ -2384,22 +1889,6 @@ static void dispc_plane_set_pixel_format(struct dispc_device *dispc,
 	WARN_ON(1);
 }
 
-static void dispc_wb_set_pixel_format(struct dispc_device *dispc,
-				      u32 fourcc)
-{
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(dispc_color_formats); ++i) {
-		if (dispc_color_formats[i].fourcc == fourcc) {
-			WB_REG_FLD_MOD(dispc, DISPC_WB_ATTRIBUTES,
-				       dispc_color_formats[i].dss_code, 6, 1);
-			return;
-		}
-	}
-
-	WARN_ON(1);
-}
-
 const u32 *dispc_plane_formats(struct dispc_device *dispc, unsigned int *len)
 {
 	WARN_ON(!dispc->fourccs);
@@ -2434,7 +1923,7 @@ int dispc_plane_check(struct dispc_device *dispc, u32 hw_plane,
 	int ret;
 
 	if (dispc_fourcc_is_yuv(fourcc)) {
-		if (!dispc_find_csc(DISPC_YUV2RGB, state->color_encoding,
+		if (!dispc_find_csc(state->color_encoding,
 				    state->color_range)) {
 			dev_dbg(dispc->dev,
 				"%s: Unsupported CSC (%u,%u) for HW plane %u\n",
@@ -2585,105 +2074,6 @@ int dispc_plane_enable(struct dispc_device *dispc, u32 hw_plane, bool enable)
 	return 0;
 }
 
-int dispc_wb_setup(struct dispc_device *dispc,
-		   const struct drm_plane_state *state,
-		   bool mem_to_mem, u32 src_hw_plane,
-		   u32 src_hw_videoport)
-{
-	u32 fourcc = state->fb->format->format;
-	u16 cpp = state->fb->format->cpp[0];
-	u32 fb_width = state->fb->pitches[0] / cpp;
-	dma_addr_t paddr = dispc_plane_state_paddr(state);
-	struct dispc_scaling_params scale;
-	enum dispc_writeback_connections wb_conn;
-
-	switch (src_hw_videoport) {
-	case 0: /* OVR_1 */
-		wb_conn = DISPC_WB_OVR1;
-		break;
-	case 1: /* OVR_2 */
-		wb_conn = DISPC_WB_OVR2;
-		break;
-	case 2: /* OVR_3 */
-		wb_conn = DISPC_WB_OVR3;
-		break;
-	case 3: /* OVR_4 */
-		wb_conn = DISPC_WB_OVR4;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	dispc_wb_calc_scaling(dispc, state, &scale);
-
-	dispc_wb_set_pixel_format(dispc, fourcc);
-
-	dispc_wb_write(dispc, DISPC_WB_BA_0, paddr & 0xffffffff);
-	dispc_wb_write(dispc, DISPC_WB_BA_EXT_0, (u64)paddr >> 32);
-	dispc_wb_write(dispc, DISPC_WB_BA_1, paddr & 0xffffffff);
-	dispc_wb_write(dispc, DISPC_WB_BA_EXT_1, (u64)paddr >> 32);
-
-	dispc_wb_write(dispc, DISPC_WB_SIZE,
-		       (scale.in_w - 1) | ((scale.in_h - 1) << 16));
-
-	dispc_wb_write(dispc, DISPC_WB_ROW_INC,
-		       pixinc(1 + (scale.yinc * fb_width -
-				   scale.xinc * scale.out_w),
-			      cpp));
-
-	if (state->fb->format->num_planes == 2) {
-		u16 cpp_uv = state->fb->format->cpp[1];
-		u32 fb_width_uv = state->fb->pitches[1] / cpp_uv;
-		dma_addr_t p_uv_addr = dispc_plane_state_p_uv_addr(state);
-
-		dispc_wb_write(dispc, DISPC_WB_BA_UV_0,
-			       p_uv_addr & 0xffffffff);
-		dispc_wb_write(dispc, DISPC_WB_BA_UV_EXT_0,
-			       (u64)p_uv_addr >> 32);
-		dispc_wb_write(dispc, DISPC_WB_BA_UV_1,
-			       p_uv_addr & 0xffffffff);
-		dispc_wb_write(dispc, DISPC_WB_BA_UV_EXT_1,
-			       (u64)p_uv_addr >> 32);
-
-		dispc_wb_write(dispc, DISPC_WB_ROW_INC_UV,
-			       pixinc(1 + (scale.yinc * fb_width_uv -
-					   scale.xinc * scale.out_w_uv),
-				      cpp_uv));
-	}
-
-	dispc_wb_write(dispc, DISPC_WB_PICTURE_SIZE,
-		       (state->crtc_w - 1) | ((state->crtc_h - 1) << 16));
-
-	dispc_wb_set_scaling(dispc, &scale, fourcc);
-
-	/* enable YUV->RGB color conversion */
-	if (dispc_fourcc_is_yuv(fourcc)) {
-		dispc_wb_csc_setup(dispc, state);
-		dispc_wb_csc_enable(dispc, true);
-	} else {
-		dispc_wb_csc_enable(dispc, false);
-	}
-
-	/* Set writeback mode */
-	WB_REG_FLD_MOD(dispc, DISPC_WB_ATTRIBUTES, mem_to_mem, 19, 19);
-
-	REG_FLD_MOD(dispc, DISPC_CONNECTIONS, wb_conn, 20, 16);
-
-	return 0;
-}
-
-int dispc_wb_enable(struct dispc_device *dispc, bool enable)
-{
-	WB_REG_FLD_MOD(dispc, DISPC_WB_ATTRIBUTES, !!enable, 0, 0);
-
-	return 0;
-}
-
-bool dispc_has_writeback(struct dispc_device *dispc)
-{
-	return dispc->wb_managed;
-}
-
 static u32 dispc_vid_get_fifo_size(struct dispc_device *dispc, u32 hw_plane)
 {
 	return VID_REG_GET(dispc, hw_plane, DISPC_VID_BUF_SIZE_STATUS, 15, 0);
@@ -2703,25 +2093,6 @@ static void dispc_vid_set_buf_threshold(struct dispc_device *dispc,
 			FLD_VAL(high, 31, 16) | FLD_VAL(low, 15, 0));
 }
 
-static u32 dispc_wb_get_fifo_size(struct dispc_device *dispc)
-{
-	return WB_REG_GET(dispc, DISPC_VID_BUF_SIZE_STATUS, 15, 0);
-}
-
-static void dispc_wb_set_mflag_threshold(struct dispc_device *dispc,
-					 u32 low, u32 high)
-{
-	dispc_wb_write(dispc, DISPC_WB_MFLAG_THRESHOLD,
-		       FLD_VAL(high, 31, 16) | FLD_VAL(low, 15, 0));
-}
-
-static void dispc_wb_set_buf_threshold(struct dispc_device *dispc,
-				       u32 low, u32 high)
-{
-	dispc_wb_write(dispc, DISPC_WB_BUF_THRESHOLD,
-		       FLD_VAL(high, 31, 16) | FLD_VAL(low, 15, 0));
-}
-
 static void dispc_k2g_plane_init(struct dispc_device *dispc)
 {
 	unsigned int hw_plane;
@@ -2821,63 +2192,6 @@ static void dispc_k3_plane_init(struct dispc_device *dispc)
 		VID_REG_FLD_MOD(dispc, hw_plane, DISPC_VID_ATTRIBUTES, 0,
 				19, 19);
 	}
-
-	if (dispc_has_writeback(dispc)) {
-		u32 size = dispc_wb_get_fifo_size(dispc);
-		u32 thr_low, thr_high;
-		u32 mflag_low, mflag_high;
-
-		thr_high = size - 1;
-		thr_low = size / 2;
-
-		mflag_high = size * 2 / 3;
-		mflag_low = size / 3;
-
-		dev_dbg(dispc->dev,
-			"wb: bufsize %u, buf_threshold %u/%u, mflag threshold %u/%u\n",
-			size,
-			thr_high, thr_low,
-			mflag_high, mflag_low);
-
-		dispc_wb_set_buf_threshold(dispc, thr_low, thr_high);
-		dispc_wb_set_mflag_threshold(dispc, mflag_low, mflag_high);
-	}
-}
-
-void dispc_wb_find_free_ovr(struct dispc_device *dispc)
-{
-	struct tidss_device *tidss = dispc->tidss;
-	int i, j;
-	bool found;
-	u32 ovr_id = 0xff;
-
-	for (i = 0; i < dispc->feat->num_vps; i++) {
-		found = false;
-		for (j = 0; j < tidss->num_crtcs; j++) {
-			struct drm_crtc *crtc = tidss->crtcs[j];
-			struct tidss_crtc *tcrtc = to_tidss_crtc(crtc);
-
-			if (tcrtc->hw_videoport == i) {
-				found = true;
-				break;
-			}
-		}
-		if (!found) {
-			/* this means this ovr is available */
-			ovr_id = i;
-			break;
-		}
-	}
-
-	if (ovr_id != 0xff)
-		dispc->wb_reserved_ovr = ovr_id;
-	else
-		dispc->wb_managed = false;
-}
-
-u32 dispc_wb_get_reserved_ovr(struct dispc_device *dispc)
-{
-	return dispc->wb_reserved_ovr;
 }
 
 static void dispc_plane_init(struct dispc_device *dispc)
@@ -3330,6 +2644,19 @@ static int dispc_init_am65x_oldi_io_ctrl(struct device *dev,
 	return 0;
 }
 
+static void dispc_init_errata(struct dispc_device *dispc)
+{
+	static const struct soc_device_attribute am65x_sr10_soc_devices[] = {
+		{ .family = "AM65X", .revision = "SR1.0" },
+		{ /* sentinel */ }
+	};
+
+	if (soc_device_match(am65x_sr10_soc_devices)) {
+		dispc->errata.i2000 = true;
+		dev_info(dispc->dev, "WA for erratum i2000: YUV formats disabled\n");
+	}
+}
+
 int dispc_init(struct tidss_device *tidss)
 {
 	struct device *dev = tidss->dev;
@@ -3353,23 +2680,27 @@ int dispc_init(struct tidss_device *tidss)
 	if (!dispc)
 		return -ENOMEM;
 
+	dispc->tidss = tidss;
+	dispc->dev = dev;
+	dispc->feat = feat;
+
+	dispc_init_errata(dispc);
+
 	dispc->fourccs = devm_kcalloc(dev, ARRAY_SIZE(dispc_color_formats),
 				      sizeof(*dispc->fourccs), GFP_KERNEL);
 	if (!dispc->fourccs)
 		return -ENOMEM;
 
-	/* Even if the feature is present we might to disabled later */
-	if (feat->has_writeback)
-		dispc->wb_managed = true;
-
 	num_fourccs = 0;
-	for (i = 0; i < ARRAY_SIZE(dispc_color_formats); ++i)
+	for (i = 0; i < ARRAY_SIZE(dispc_color_formats); ++i) {
+		if (dispc->errata.i2000 &&
+		    dispc_fourcc_is_yuv(dispc_color_formats[i].fourcc)) {
+			continue;
+		}
 		dispc->fourccs[num_fourccs++] = dispc_color_formats[i].fourcc;
+	}
 
 	dispc->num_fourccs = num_fourccs;
-	dispc->tidss = tidss;
-	dispc->dev = dev;
-	dispc->feat = feat;
 
 	dispc_common_regmap = dispc->feat->common_regs;
 
@@ -3385,13 +2716,6 @@ int dispc_init(struct tidss_device *tidss)
 			return r;
 	}
 
-	if (dispc_has_writeback(dispc)) {
-		r = dispc_iomap_resource(pdev, dispc->feat->wb_name,
-					 &dispc->base_wb);
-		if (r)
-			return r;
-	}
-
 	for (i = 0; i < dispc->feat->num_vps; i++) {
 		u32 gamma_size = dispc->feat->vp_feat.color.gamma_size;
 		u32 *gamma_table;
diff --git a/drivers/gpu/drm/tidss/tidss_dispc.h b/drivers/gpu/drm/tidss/tidss_dispc.h
index 8eb49746c214..e49432f0abf5 100644
--- a/drivers/gpu/drm/tidss/tidss_dispc.h
+++ b/drivers/gpu/drm/tidss/tidss_dispc.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2018 Texas Instruments Incorporated - https://www.ti.com/
  * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  */
 
@@ -46,6 +46,10 @@ struct dispc_features_scaling {
 	u32 xinc_max;
 };
 
+struct dispc_errata {
+	bool i2000; /* DSS Does Not Support YUV Pixel Data Formats */
+};
+
 enum dispc_vp_bus_type {
 	DISPC_VP_DPI,		/* DPI output */
 	DISPC_VP_OLDI,		/* OLDI (LVDS) output */
@@ -79,9 +83,6 @@ struct dispc_features {
 	const char *vid_name[TIDSS_MAX_PLANES]; /* Should match dt reg names */
 	bool vid_lite[TIDSS_MAX_PLANES];
 	u32 vid_order[TIDSS_MAX_PLANES];
-
-	bool has_writeback;
-	const char *wb_name; /* Should match dt reg names */
 };
 
 extern const struct dispc_features dispc_k2g_feats;
@@ -127,14 +128,6 @@ int dispc_plane_setup(struct dispc_device *dispc, u32 hw_plane,
 		      u32 hw_videoport);
 int dispc_plane_enable(struct dispc_device *dispc, u32 hw_plane, bool enable);
 const u32 *dispc_plane_formats(struct dispc_device *dispc, unsigned int *len);
-bool dispc_has_writeback(struct dispc_device *dispc);
-int dispc_wb_setup(struct dispc_device *dispc,
-		   const struct drm_plane_state *state,
-		   bool mem_to_mem, u32 src_hw_plane,
-		   u32 src_hw_videoport);
-int dispc_wb_enable(struct dispc_device *dispc, bool enable);
-void dispc_wb_find_free_ovr(struct dispc_device *dispc);
-u32 dispc_wb_get_reserved_ovr(struct dispc_device *dispc);
 
 int dispc_init(struct tidss_device *tidss);
 void dispc_remove(struct tidss_device *tidss);
diff --git a/drivers/gpu/drm/tidss/tidss_dispc_regs.h b/drivers/gpu/drm/tidss/tidss_dispc_regs.h
index 53a65a5f5123..13feedfe5d6d 100644
--- a/drivers/gpu/drm/tidss/tidss_dispc_regs.h
+++ b/drivers/gpu/drm/tidss/tidss_dispc_regs.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2016-2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2016-2018 Texas Instruments Incorporated - https://www.ti.com/
  * Author: Jyri Sarha <jsarha@ti.com>
  */
 
@@ -46,15 +46,6 @@ enum dispc_common_regs {
 	DISPC_COMMON_REG_TABLE_LEN,
 };
 
-enum dispc_writeback_connections {
-	DISPC_WB_BYPASS = 0x0,
-	DISPC_WB_VIDL2 = 0x1,
-	DISPC_WB_OVR1 = 0x2,
-	DISPC_WB_OVR2 = 0x4,
-	DISPC_WB_OVR3 = 0x8,
-	DISPC_WB_OVR4 = 0x10,
-};
-
 /*
  * dispc_common_regmap should be defined as const u16 * and pointing
  * to a valid dss common register map for the platform, before the
@@ -171,64 +162,6 @@ enum dispc_writeback_connections {
 #define DISPC_VID_LUMAKEY		0x2b8
 #define DISPC_VID_DMA_BUFSIZE		0x2bc /* J721E */
 
-/* WB */
-
-#define DISPC_WB_ACCUH_0                0x0
-#define DISPC_WB_ACCUH_1                0x4
-#define DISPC_WB_ACCUH2_0               0x8
-#define DISPC_WB_ACCUH2_1               0xc
-#define DISPC_WB_ACCUV_0                0x10
-#define DISPC_WB_ACCUV_1                0x14
-#define DISPC_WB_ACCUV2_0               0x18
-#define DISPC_WB_ACCUV2_1               0x1c
-#define DISPC_WB_ATTRIBUTES             0x20
-#define DISPC_WB_ATTRIBUTES2            0x24
-#define DISPC_WB_BA_0                   0x28
-#define DISPC_WB_BA_1                   0x2c
-#define DISPC_WB_BA_UV_0                0x30
-#define DISPC_WB_BA_UV_1                0x34
-#define DISPC_WB_BUF_SIZE_STATUS        0x38
-#define DISPC_WB_BUF_THRESHOLD          0x3c
-#define DISPC_WB_CSC_COEF(n)            (0x40 + (n) * 4)
-
-#define DISPC_WB_FIRH                   0x5c
-#define DISPC_WB_FIRH2                  0x60
-#define DISPC_WB_FIRV                   0x64
-#define DISPC_WB_FIRV2                  0x68
-
-#define DISPC_WB_FIR_COEFS_H0           0x6c
-#define DISPC_WB_FIR_COEF_H0(phase)     (0x6c + (phase) * 4)
-#define DISPC_WB_FIR_COEFS_H0_C 0x90
-#define DISPC_WB_FIR_COEF_H0_C(phase)   (0x90 + (phase) * 4)
-
-#define DISPC_WB_FIR_COEFS_H12          0xb4
-#define DISPC_WB_FIR_COEF_H12(phase)    (0xb4 + (phase) * 4)
-#define DISPC_WB_FIR_COEFS_H12_C        0xf4
-#define DISPC_WB_FIR_COEF_H12_C(phase)  (0xf4 + (phase) * 4)
-
-#define DISPC_WB_FIR_COEFS_V0           0x134
-#define DISPC_WB_FIR_COEF_V0(phase)     (0x134 + (phase) * 4)
-#define DISPC_WB_FIR_COEFS_V0_C 0x158
-#define DISPC_WB_FIR_COEF_V0_C(phase)   (0x158 + (phase) * 4)
-
-#define DISPC_WB_FIR_COEFS_V12          0x17c
-#define DISPC_WB_FIR_COEF_V12(phase)    (0x17c + (phase) * 4)
-#define DISPC_WB_FIR_COEFS_V12_C        0x1bc
-#define DISPC_WB_FIR_COEF_V12_C(phase)  (0x1bc + (phase) * 4)
-
-#define DISPC_WB_MFLAG_THRESHOLD        0x204
-#define DISPC_WB_PICTURE_SIZE           0x208
-#define DISPC_WB_SIZE                   0x210
-#define DISPC_WB_POSITION               0x214
-#define DISPC_WB_CSC_COEF7              0x21c
-#define DISPC_WB_ROW_INC                0x224
-#define DISPC_WB_ROW_INC_UV             0x228
-#define DISPC_WB_BA_EXT_0               0x22c
-#define DISPC_WB_BA_EXT_1               0x230
-#define DISPC_WB_BA_UV_EXT_0            0x234
-#define DISPC_WB_BA_UV_EXT_1            0x238
-#define DISPC_WB_SECURE                 0x248
-
 /* OVR */
 
 #define DISPC_OVR_CONFIG		0x0
diff --git a/drivers/gpu/drm/tidss/tidss_drv.c b/drivers/gpu/drm/tidss/tidss_drv.c
index c58bbcff627a..6eca34907cec 100644
--- a/drivers/gpu/drm/tidss/tidss_drv.c
+++ b/drivers/gpu/drm/tidss/tidss_drv.c
@@ -1,9 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2018 Texas Instruments Incorporated - https://www.ti.com/
  * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  */
-
+#define DEBUG 1
 #include <linux/console.h>
 #include <linux/of_device.h>
 #include <linux/module.h>
@@ -17,6 +17,7 @@
 #include <drm/drm_fb_helper.h>
 #include <drm/drm_gem_cma_helper.h>
 #include <drm/drm_irq.h>
+#include <drm/drm_managed.h>
 #include <drm/drm_probe_helper.h>
 
 #include "tidss_dispc.h"
@@ -102,15 +103,7 @@ static const struct dev_pm_ops tidss_pm_ops = {
 
 static void tidss_release(struct drm_device *ddev)
 {
-	struct tidss_device *tidss = ddev->dev_private;
-
 	drm_kms_helper_poll_fini(ddev);
-
-	tidss_modeset_cleanup(tidss);
-
-	drm_dev_fini(ddev);
-
-	kfree(tidss);
 }
 
 DEFINE_DRM_GEM_CMA_FOPS(tidss_fops);
@@ -119,7 +112,7 @@ static struct drm_driver tidss_driver = {
 	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
 	.fops			= &tidss_fops,
 	.release		= tidss_release,
-	DRM_GEM_CMA_VMAP_DRIVER_OPS,
+	DRM_GEM_CMA_DRIVER_OPS_VMAP,
 	.name			= "tidss",
 	.desc			= "TI Keystone DSS",
 	.date			= "20180215",
@@ -142,26 +135,18 @@ static int tidss_probe(struct platform_device *pdev)
 
 	dev_dbg(dev, "%s\n", __func__);
 
-	/* Can't use devm_* since drm_device's lifetime may exceed dev's */
-	tidss = kzalloc(sizeof(*tidss), GFP_KERNEL);
-	if (!tidss)
-		return -ENOMEM;
+	tidss = devm_drm_dev_alloc(&pdev->dev, &tidss_driver,
+				   struct tidss_device, ddev);
+	if (IS_ERR(tidss))
+		return PTR_ERR(tidss);
 
 	ddev = &tidss->ddev;
 
-	ret = devm_drm_dev_init(&pdev->dev, ddev, &tidss_driver);
-	if (ret) {
-		kfree(ddev);
-		return ret;
-	}
-
 	tidss->dev = dev;
 	tidss->feat = of_device_get_match_data(dev);
 
 	platform_set_drvdata(pdev, tidss);
 
-	ddev->dev_private = tidss;
-
 	ret = dispc_init(tidss);
 	if (ret) {
 		dev_err(dev, "failed to initialize dispc: %d\n", ret);
@@ -198,14 +183,6 @@ static int tidss_probe(struct platform_device *pdev)
 
 	drm_mode_config_reset(ddev);
 
-	if (dispc_has_writeback(tidss->dispc)) {
-		ret = tidss_wb_init(ddev);
-		if (ret)
-			dev_warn(dev, "failed to initialize writeback\n");
-		else
-			tidss->wb_initialized = true;
-	}
-
 	ret = drm_dev_register(ddev, 0);
 	if (ret) {
 		dev_err(dev, "failed to register DRM device\n");
@@ -219,9 +196,6 @@ static int tidss_probe(struct platform_device *pdev)
 	return 0;
 
 err_irq_uninstall:
-	if (tidss->wb_initialized)
-		tidss_wb_cleanup(ddev);
-
 	drm_irq_uninstall(ddev);
 
 err_runtime_suspend:
@@ -243,9 +217,6 @@ static int tidss_remove(struct platform_device *pdev)
 
 	drm_dev_unregister(ddev);
 
-	if (tidss->wb_initialized)
-		tidss_wb_cleanup(ddev);
-
 	drm_atomic_helper_shutdown(ddev);
 
 	drm_irq_uninstall(ddev);
diff --git a/drivers/gpu/drm/tidss/tidss_drv.h b/drivers/gpu/drm/tidss/tidss_drv.h
index 145178463612..7de4bba52e6f 100644
--- a/drivers/gpu/drm/tidss/tidss_drv.h
+++ b/drivers/gpu/drm/tidss/tidss_drv.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2018 Texas Instruments Incorporated - https://www.ti.com/
  * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  */
 
@@ -14,8 +14,6 @@
 
 typedef u32 dispc_irq_t;
 
-struct wb_dev;
-
 struct tidss_device {
 	struct drm_device ddev;		/* DRM device for DSS */
 	struct device *dev;		/* Underlying DSS device */
@@ -31,27 +29,9 @@ struct tidss_device {
 
 	spinlock_t wait_lock;	/* protects the irq masks */
 	dispc_irq_t irq_mask;	/* enabled irqs in addition to wait_list */
-
-	struct drm_atomic_state *saved_state;
-
-	struct wb_dev *wdev;	/* Write-back private data */
-	bool wb_initialized;
 };
 
-
-#if IS_ENABLED(CONFIG_DRM_TIDSS_WB)
-
-int tidss_wb_init(struct drm_device *drmdev);
-void tidss_wb_cleanup(struct drm_device *drmdev);
-void tidss_wb_irq(struct wb_dev *wdev, dispc_irq_t irqstatus);
-
-#else
-
-static inline int tidss_wb_init(struct drm_device *drmdev) { return 0; }
-static inline void tidss_wb_cleanup(struct drm_device *drmdev) { }
-static inline void tidss_wb_irq(struct wb_dev *wdev, dispc_irq_t irqstatus) { }
-
-#endif
+#define to_tidss(__dev) container_of(__dev, struct tidss_device, ddev)
 
 int tidss_runtime_get(struct tidss_device *tidss);
 void tidss_runtime_put(struct tidss_device *tidss);
diff --git a/drivers/gpu/drm/tidss/tidss_encoder.c b/drivers/gpu/drm/tidss/tidss_encoder.c
index 1fc14a9e147e..ade369e0578d 100644
--- a/drivers/gpu/drm/tidss/tidss_encoder.c
+++ b/drivers/gpu/drm/tidss/tidss_encoder.c
@@ -1,9 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2018 Texas Instruments Incorporated - https://www.ti.com/
  * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  */
-
+#define DEBUG 1
 #include <linux/export.h>
 
 #include <drm/drm_crtc.h>
@@ -32,7 +32,7 @@ static int tidss_encoder_atomic_check(struct drm_encoder *encoder,
 	 * bridge timings, or from the connector's display_info if no
 	 * bridge defines the timings.
 	 */
-	for (bridge = encoder->bridge; bridge; bridge = bridge->next) {
+	drm_for_each_bridge_in_chain(encoder, bridge) {
 		if (!bridge->timings)
 			continue;
 
diff --git a/drivers/gpu/drm/tidss/tidss_encoder.h b/drivers/gpu/drm/tidss/tidss_encoder.h
index 06854d66e7e6..ace877c0e0fd 100644
--- a/drivers/gpu/drm/tidss/tidss_encoder.h
+++ b/drivers/gpu/drm/tidss/tidss_encoder.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2018 Texas Instruments Incorporated - https://www.ti.com/
  * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  */
 
diff --git a/drivers/gpu/drm/tidss/tidss_irq.c b/drivers/gpu/drm/tidss/tidss_irq.c
index 393ee634dcad..706a2067b330 100644
--- a/drivers/gpu/drm/tidss/tidss_irq.c
+++ b/drivers/gpu/drm/tidss/tidss_irq.c
@@ -1,9 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2018 Texas Instruments Incorporated - https://www.ti.com/
  * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  */
-
+#define DEBUG 1
 #include <drm/drm_print.h>
 
 #include "tidss_crtc.h"
@@ -23,7 +23,7 @@ static void tidss_irq_update(struct tidss_device *tidss)
 void tidss_irq_enable_vblank(struct drm_crtc *crtc)
 {
 	struct drm_device *ddev = crtc->dev;
-	struct tidss_device *tidss = ddev->dev_private;
+	struct tidss_device *tidss = to_tidss(ddev);
 	struct tidss_crtc *tcrtc = to_tidss_crtc(crtc);
 	u32 hw_videoport = tcrtc->hw_videoport;
 	unsigned long flags;
@@ -38,7 +38,7 @@ void tidss_irq_enable_vblank(struct drm_crtc *crtc)
 void tidss_irq_disable_vblank(struct drm_crtc *crtc)
 {
 	struct drm_device *ddev = crtc->dev;
-	struct tidss_device *tidss = ddev->dev_private;
+	struct tidss_device *tidss = to_tidss(ddev);
 	struct tidss_crtc *tcrtc = to_tidss_crtc(crtc);
 	u32 hw_videoport = tcrtc->hw_videoport;
 	unsigned long flags;
@@ -53,7 +53,7 @@ void tidss_irq_disable_vblank(struct drm_crtc *crtc)
 irqreturn_t tidss_irq_handler(int irq, void *arg)
 {
 	struct drm_device *ddev = (struct drm_device *)arg;
-	struct tidss_device *tidss = ddev->dev_private;
+	struct tidss_device *tidss = to_tidss(ddev);
 	unsigned int id;
 	dispc_irq_t irqstatus;
 
@@ -80,7 +80,6 @@ irqreturn_t tidss_irq_handler(int irq, void *arg)
 
 	if (irqstatus & DSS_IRQ_DEVICE_OCP_ERR)
 		dev_err_ratelimited(tidss->dev, "OCP error\n");
-	tidss_wb_irq(tidss->wdev, irqstatus);
 
 	return IRQ_HANDLED;
 }
@@ -96,7 +95,7 @@ void tidss_irq_resume(struct tidss_device *tidss)
 
 void tidss_irq_preinstall(struct drm_device *ddev)
 {
-	struct tidss_device *tidss = ddev->dev_private;
+	struct tidss_device *tidss = to_tidss(ddev);
 
 	spin_lock_init(&tidss->wait_lock);
 
@@ -110,7 +109,7 @@ void tidss_irq_preinstall(struct drm_device *ddev)
 
 int tidss_irq_postinstall(struct drm_device *ddev)
 {
-	struct tidss_device *tidss = ddev->dev_private;
+	struct tidss_device *tidss = to_tidss(ddev);
 	unsigned long flags;
 	unsigned int i;
 
@@ -128,9 +127,6 @@ int tidss_irq_postinstall(struct drm_device *ddev)
 		tidss->irq_mask |= DSS_IRQ_VP_FRAME_DONE(tcrtc->hw_videoport);
 	}
 
-	if (dispc_has_writeback(tidss->dispc))
-		tidss->irq_mask |= DSS_IRQ_DEVICE_WB_MASK;
-
 	tidss_irq_update(tidss);
 
 	spin_unlock_irqrestore(&tidss->wait_lock, flags);
@@ -142,7 +138,7 @@ int tidss_irq_postinstall(struct drm_device *ddev)
 
 void tidss_irq_uninstall(struct drm_device *ddev)
 {
-	struct tidss_device *tidss = ddev->dev_private;
+	struct tidss_device *tidss = to_tidss(ddev);
 
 	tidss_runtime_get(tidss);
 	dispc_set_irqenable(tidss->dispc, 0);
diff --git a/drivers/gpu/drm/tidss/tidss_irq.h b/drivers/gpu/drm/tidss/tidss_irq.h
index cd330eee2b3f..4aaad5dfd7c2 100644
--- a/drivers/gpu/drm/tidss/tidss_irq.h
+++ b/drivers/gpu/drm/tidss/tidss_irq.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2018 Texas Instruments Incorporated - https://www.ti.com/
  * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  */
 
@@ -15,14 +15,13 @@
  * The IRQ status from various DISPC IRQ registers are packed into a single
  * value, where the bits are defined as follows:
  *
- * bit group |dev|wb |mrg0|mrg1|mrg2|mrg3|plane0-3|wb   | <unused> |
- * bit use   |D  |fou|FEOL|FEOL|FEOL|FEOL|  UUUU  |vs   |          |
- * bit number|0  |1-3|4-7 |8-11|  12-19  | 20-23  |24-25|  26-31   |
+ * bit group |dev|wb |mrg0|mrg1|mrg2|mrg3|plane0-3| <unused> |
+ * bit use   |D  |fou|FEOL|FEOL|FEOL|FEOL|  UUUU  |          |
+ * bit number|0  |1-3|4-7 |8-11|  12-19  | 20-23  |  24-31   |
  *
  * device bits:	D = OCP error
  * WB bits:	f = frame done wb, o = wb buffer overflow,
- *		u = wb buffer uncomplete, v = wb security violation,
- *		s = wb sync
+ *		u = wb buffer uncomplete
  * vp bits:	F = frame done, E = vsync even, O = vsync odd, L = sync lost
  * plane bits:	U = fifo underflow
  */
@@ -32,9 +31,7 @@
 #define DSS_IRQ_DEVICE_FRAMEDONEWB		BIT(1)
 #define DSS_IRQ_DEVICE_WBBUFFEROVERFLOW		BIT(2)
 #define DSS_IRQ_DEVICE_WBUNCOMPLETEERROR	BIT(3)
-#define DSS_IRQ_DEVICE_WBSECURITYVIOLATION	BIT(24)
-#define DSS_IRQ_DEVICE_WBSYNC			BIT(25)
-#define DSS_IRQ_DEVICE_WB_MASK			(GENMASK(3, 1) | BIT(24) | BIT(25))
+#define DSS_IRQ_DEVICE_WB_MASK			GENMASK(3, 1)
 
 #define DSS_IRQ_VP_BIT_N(ch, bit)	(4 + 4 * (ch) + (bit))
 #define DSS_IRQ_PLANE_BIT_N(plane, bit) \
diff --git a/drivers/gpu/drm/tidss/tidss_kms.c b/drivers/gpu/drm/tidss/tidss_kms.c
index 4ea2b44090e2..15c64c3cdc19 100644
--- a/drivers/gpu/drm/tidss/tidss_kms.c
+++ b/drivers/gpu/drm/tidss/tidss_kms.c
@@ -1,9 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2018 Texas Instruments Incorporated - https://www.ti.com/
  * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  */
-
+#define DEBUG 1
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_bridge.h>
@@ -25,7 +25,7 @@
 static void tidss_atomic_commit_tail(struct drm_atomic_state *old_state)
 {
 	struct drm_device *ddev = old_state->dev;
-	struct tidss_device *tidss = ddev->dev_private;
+	struct tidss_device *tidss = to_tidss(ddev);
 
 	dev_dbg(ddev->dev, "%s\n", __func__);
 
@@ -154,15 +154,22 @@ static int tidss_dispc_modeset_init(struct tidss_device *tidss)
 				break;
 			case DISPC_VP_DPI:
 				enc_type = DRM_MODE_ENCODER_DPI;
-				conn_type = DRM_MODE_CONNECTOR_LVDS;
+				conn_type = DRM_MODE_CONNECTOR_DPI;
 				break;
 			default:
 				WARN_ON(1);
 				return -EINVAL;
 			}
 
-			bridge = devm_drm_panel_bridge_add(dev, panel,
-							   conn_type);
+			if (panel->connector_type != conn_type) {
+				dev_err(dev,
+					"%s: Panel %s has incompatible connector type for vp%d (%d != %d)\n",
+					 __func__, dev_name(panel->dev), i,
+					 panel->connector_type, conn_type);
+				return -EINVAL;
+			}
+
+			bridge = devm_drm_panel_bridge_add(dev, panel);
 			if (IS_ERR(bridge)) {
 				dev_err(dev,
 					"failed to set up panel bridge for port %d\n",
@@ -215,17 +222,13 @@ static int tidss_dispc_modeset_init(struct tidss_device *tidss)
 			return PTR_ERR(enc);
 		}
 
-		ret = drm_bridge_attach(enc, pipes[i].bridge, NULL);
+		ret = drm_bridge_attach(enc, pipes[i].bridge, NULL, 0);
 		if (ret) {
 			dev_err(tidss->dev, "bridge attach failed: %d\n", ret);
 			return ret;
 		}
 	}
 
-	/* Try to find an available OVR to use for WB */
-	if (dispc_has_writeback(tidss->dispc))
-		dispc_wb_find_free_ovr(tidss->dispc);
-
 	/* create overlay planes of the leftover planes */
 
 	while (tidss->num_planes < max_planes) {
@@ -250,12 +253,13 @@ static int tidss_dispc_modeset_init(struct tidss_device *tidss)
 int tidss_modeset_init(struct tidss_device *tidss)
 {
 	struct drm_device *ddev = &tidss->ddev;
-	unsigned int i;
 	int ret;
 
 	dev_dbg(tidss->dev, "%s\n", __func__);
 
-	drm_mode_config_init(ddev);
+	ret = drmm_mode_config_init(ddev);
+	if (ret)
+		return ret;
 
 	ddev->mode_config.min_width = 8;
 	ddev->mode_config.min_height = 8;
@@ -267,30 +271,15 @@ int tidss_modeset_init(struct tidss_device *tidss)
 
 	ret = tidss_dispc_modeset_init(tidss);
 	if (ret)
-		goto err_mode_config_cleanup;
+		return ret;
 
 	ret = drm_vblank_init(ddev, tidss->num_crtcs);
 	if (ret)
-		goto err_mode_config_cleanup;
-
-	/* Start with vertical blanking interrupt reporting disabled. */
-	for (i = 0; i < tidss->num_crtcs; ++i)
-		drm_crtc_vblank_reset(tidss->crtcs[i]);
+		return ret;
 
 	drm_mode_config_reset(ddev);
 
 	dev_dbg(tidss->dev, "%s done\n", __func__);
 
 	return 0;
-
-err_mode_config_cleanup:
-	drm_mode_config_cleanup(ddev);
-	return ret;
-}
-
-void tidss_modeset_cleanup(struct tidss_device *tidss)
-{
-	struct drm_device *ddev = &tidss->ddev;
-
-	drm_mode_config_cleanup(ddev);
 }
diff --git a/drivers/gpu/drm/tidss/tidss_kms.h b/drivers/gpu/drm/tidss/tidss_kms.h
index dda5625d0128..632d79f5983f 100644
--- a/drivers/gpu/drm/tidss/tidss_kms.h
+++ b/drivers/gpu/drm/tidss/tidss_kms.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2018 Texas Instruments Incorporated - https://www.ti.com/
  * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  */
 
@@ -10,6 +10,5 @@
 struct tidss_device;
 
 int tidss_modeset_init(struct tidss_device *tidss);
-void tidss_modeset_cleanup(struct tidss_device *tidss);
 
 #endif
diff --git a/drivers/gpu/drm/tidss/tidss_plane.c b/drivers/gpu/drm/tidss/tidss_plane.c
index f5fa43b875d6..b9ec5f4cf5e9 100644
--- a/drivers/gpu/drm/tidss/tidss_plane.c
+++ b/drivers/gpu/drm/tidss/tidss_plane.c
@@ -1,16 +1,15 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2018 Texas Instruments Incorporated - https://www.ti.com/
  * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  */
-
+#define DEBUG 1
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_crtc_helper.h>
 #include <drm/drm_fourcc.h>
 #include <drm/drm_fb_cma_helper.h>
-#include <drm/drm_gem_framebuffer_helper.h>
 
 #include "tidss_crtc.h"
 #include "tidss_dispc.h"
@@ -23,7 +22,7 @@ static int tidss_plane_atomic_check(struct drm_plane *plane,
 				    struct drm_plane_state *state)
 {
 	struct drm_device *ddev = plane->dev;
-	struct tidss_device *tidss = ddev->dev_private;
+	struct tidss_device *tidss = to_tidss(ddev);
 	struct tidss_plane *tplane = to_tidss_plane(plane);
 	const struct drm_format_info *finfo;
 	struct drm_crtc_state *crtc_state;
@@ -33,9 +32,6 @@ static int tidss_plane_atomic_check(struct drm_plane *plane,
 
 	dev_dbg(ddev->dev, "%s\n", __func__);
 
-	if (tplane->reserved_wb)
-		return -EBUSY;
-
 	if (!state->crtc) {
 		/*
 		 * The visible field is not reset by the DRM core but only
@@ -105,7 +101,7 @@ static void tidss_plane_atomic_update(struct drm_plane *plane,
 				      struct drm_plane_state *old_state)
 {
 	struct drm_device *ddev = plane->dev;
-	struct tidss_device *tidss = ddev->dev_private;
+	struct tidss_device *tidss = to_tidss(ddev);
 	struct tidss_plane *tplane = to_tidss_plane(plane);
 	struct drm_plane_state *state = plane->state;
 	u32 hw_videoport;
@@ -137,7 +133,7 @@ static void tidss_plane_atomic_disable(struct drm_plane *plane,
 				       struct drm_plane_state *old_state)
 {
 	struct drm_device *ddev = plane->dev;
-	struct tidss_device *tidss = ddev->dev_private;
+	struct tidss_device *tidss = to_tidss(ddev);
 	struct tidss_plane *tplane = to_tidss_plane(plane);
 
 	dev_dbg(ddev->dev, "%s\n", __func__);
@@ -154,7 +150,6 @@ static void drm_plane_destroy(struct drm_plane *plane)
 }
 
 static const struct drm_plane_helper_funcs tidss_plane_helper_funcs = {
-	.prepare_fb = drm_gem_fb_prepare_fb,
 	.atomic_check = tidss_plane_atomic_check,
 	.atomic_update = tidss_plane_atomic_update,
 	.atomic_disable = tidss_plane_atomic_disable,
@@ -232,42 +227,3 @@ struct tidss_plane *tidss_plane_create(struct tidss_device *tidss,
 	kfree(tplane);
 	return ERR_PTR(ret);
 }
-
-struct drm_plane *tidss_plane_reserve_wb(struct drm_device *dev)
-{
-	struct tidss_device *tidss = dev->dev_private;
-	int i;
-	u32 ovr_id = dispc_wb_get_reserved_ovr(tidss->dispc);
-
-	for (i = tidss->num_planes - 1; i >= 0; --i) {
-		struct drm_plane *plane = tidss->planes[i];
-		struct tidss_plane *tplane = to_tidss_plane(plane);
-
-		if (plane->state->crtc || plane->state->fb)
-			continue;
-
-		if (tplane->reserved_wb)
-			continue;
-
-		/*
-		 * We found an available plane so just mark the
-		 * associated video port as the one found in the last step
-		 */
-		tplane->reserved_wb = true;
-
-		dev_dbg(dev->dev, "%s: found plane: %d on ovr: %d\n",
-			__func__, tplane->hw_plane_id, ovr_id);
-
-		return plane;
-	}
-	return NULL;
-}
-
-void tidss_plane_release_wb(struct drm_plane *plane)
-{
-	struct tidss_plane *tplane = to_tidss_plane(plane);
-
-	WARN_ON(!tplane->reserved_wb);
-
-	tplane->reserved_wb = false;
-}
diff --git a/drivers/gpu/drm/tidss/tidss_plane.h b/drivers/gpu/drm/tidss/tidss_plane.h
index a66be66bd9ec..e933e158b617 100644
--- a/drivers/gpu/drm/tidss/tidss_plane.h
+++ b/drivers/gpu/drm/tidss/tidss_plane.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2018 Texas Instruments Incorporated - https://www.ti.com/
  * Author: Tomi Valkeinen <tomi.valkeinen@ti.com>
  */
 
@@ -15,15 +15,11 @@ struct tidss_plane {
 	struct drm_plane plane;
 
 	u32 hw_plane_id;
-
-	bool reserved_wb;
 };
 
 struct tidss_plane *tidss_plane_create(struct tidss_device *tidss,
 				       u32 hw_plane_id, u32 plane_type,
 				       u32 crtc_mask, const u32 *formats,
 				       u32 num_formats);
-struct drm_plane *tidss_plane_reserve_wb(struct drm_device *dev);
-void tidss_plane_release_wb(struct drm_plane *plane);
 
 #endif
diff --git a/drivers/gpu/drm/tidss/tidss_scale_coefs.c b/drivers/gpu/drm/tidss/tidss_scale_coefs.c
index 5ec68389cc68..ff430a28295f 100644
--- a/drivers/gpu/drm/tidss/tidss_scale_coefs.c
+++ b/drivers/gpu/drm/tidss/tidss_scale_coefs.c
@@ -1,9 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2018 Texas Instruments Incorporated - https://www.ti.com/
  * Author: Jyri Sarha <jsarha@ti.com>
  */
-
+#define DEBUG 1
 #include <linux/device.h>
 #include <linux/kernel.h>
 
diff --git a/drivers/gpu/drm/tidss/tidss_scale_coefs.h b/drivers/gpu/drm/tidss/tidss_scale_coefs.h
index 64b5af5b5361..9c560d0fdac0 100644
--- a/drivers/gpu/drm/tidss/tidss_scale_coefs.h
+++ b/drivers/gpu/drm/tidss/tidss_scale_coefs.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
+ * Copyright (C) 2018 Texas Instruments Incorporated - https://www.ti.com/
  * Author: Jyri Sarha <jsarha@ti.com>
  */
 
diff --git a/drivers/gpu/drm/tidss/tidss_wb.c b/drivers/gpu/drm/tidss/tidss_wb.c
deleted file mode 100644
index 148b26b3ae9b..000000000000
--- a/drivers/gpu/drm/tidss/tidss_wb.c
+++ /dev/null
@@ -1,166 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2019 Texas Instruments Incorporated -  http://www.ti.com/
- * Author: Benoit Parrot <bparrot@ti.com>
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-
-#include "tidss_wb.h"
-
-unsigned int tidss_wbdebug;
-module_param(tidss_wbdebug, uint, 0644);
-MODULE_PARM_DESC(wbdebug, "activates debug info");
-
-const struct wb_fmt tidss_wb_formats[] = {
-	{
-		.fourcc		= V4L2_PIX_FMT_NV12,
-		.coplanar	= 0,
-		.depth		= {8, 4},
-	},
-	{
-		.fourcc		= V4L2_PIX_FMT_NV12M,
-		.coplanar	= 1,
-		.depth		= {8, 4},
-	},
-	{
-		.fourcc		= V4L2_PIX_FMT_YUYV,
-		.coplanar	= 0,
-		.depth		= {16, 0},
-	},
-	{
-		.fourcc		= V4L2_PIX_FMT_UYVY,
-		.coplanar	= 0,
-		.depth		= {16, 0},
-	},
-	{
-		/* "XR24", DRM_FORMAT_XRGB8888 */
-		.fourcc		= V4L2_PIX_FMT_XBGR32,
-		.coplanar	= 0,
-		.depth		= {32, 0},
-	},
-};
-
-const unsigned int tidss_num_wb_formats = ARRAY_SIZE(tidss_wb_formats);
-
-/* find our format description corresponding to the passed v4l2_format */
-const struct wb_fmt *__tidss_wb_find_format(u32 fourcc)
-{
-	const struct wb_fmt *fmt;
-	unsigned int k;
-
-	for (k = 0; k < tidss_num_wb_formats; k++) {
-		fmt = &tidss_wb_formats[k];
-		if (fmt->fourcc == fourcc)
-			return fmt;
-	}
-
-	return NULL;
-}
-
-const struct wb_fmt *tidss_wb_find_format(struct v4l2_format *f)
-{
-	return __tidss_wb_find_format(f->fmt.pix_mp.pixelformat);
-}
-
-int tidss_wb_fourcc_v4l2_to_drm(u32 fourcc)
-{
-	switch (fourcc) {
-	case V4L2_PIX_FMT_NV12:
-	case V4L2_PIX_FMT_NV12M:
-		return DRM_FORMAT_NV12;
-	case V4L2_PIX_FMT_YUYV:
-		return DRM_FORMAT_YUYV;
-	case V4L2_PIX_FMT_UYVY:
-		return DRM_FORMAT_UYVY;
-	case V4L2_PIX_FMT_XBGR32:
-		return DRM_FORMAT_XRGB8888;
-	default:
-		WARN(1, "WB: unsupported fourcc\n");
-		return 0;
-	}
-}
-
-void tidss_wb_irq(struct wb_dev *wdev, dispc_irq_t irqstatus)
-{
-	const dispc_irq_t mask = DSS_IRQ_DEVICE_WB_MASK;
-
-	if (!wdev)
-		return;
-
-	irqstatus &= mask;
-	if (!irqstatus)
-		return;
-
-	if (!atomic_read(&wdev->irq_enabled))
-		return;
-
-	switch (wdev->mode) {
-	case TIDSS_WB_NOT_CONFIGURED:
-		break;
-	case TIDSS_WB_MEM2MEM_OVL:
-		tidss_wbm2m_irq(wdev->m2m, irqstatus);
-		break;
-	case TIDSS_WB_MEM2MEM_MGR:
-		/* To be added */
-		break;
-	case TIDSS_WB_CAPTURE_MGR:
-		/* To be added */
-		break;
-	default:
-		WARN_ONCE(1, "WB: unknown WB mode: 0x%x\n", wdev->mode);
-		break;
-	}
-}
-
-/*
- * The initial setup of this device instance. Note that the initial state of
- * the driver should be complete. So the initial format, standard, timings
- * and video input should all be initialized to some reasonable value.
- */
-int tidss_wb_init(struct drm_device *drmdev)
-{
-	struct tidss_device *tidss = drmdev->dev_private;
-	struct wb_dev *wdev;
-	int ret = 0;
-
-	/* Allocate a new instance */
-	wdev = devm_kzalloc(drmdev->dev, sizeof(*wdev), GFP_KERNEL);
-	if (!wdev)
-		return -ENOMEM;
-
-	wdev->drm_dev = drmdev;
-
-	/* set pseudo v4l2 device name so we can use v4l2_printk */
-	strlcpy(wdev->v4l2_dev.name, WB_MODULE_NAME,
-		sizeof(wdev->v4l2_dev.name));
-
-	tidss->wdev = wdev;
-
-	mutex_init(&wdev->lock);
-
-	atomic_set(&wdev->irq_enabled, 0);
-
-	wdev->mode = TIDSS_WB_NOT_CONFIGURED;
-
-	ret = tidss_wbm2m_init(wdev);
-	if (ret) {
-		log_err(wdev, "Failed to initialize wb m2m\n");
-		return ret;
-	}
-
-	log_dbg(wdev, "WB loaded\n");
-	return 0;
-}
-
-void tidss_wb_cleanup(struct drm_device *drmdev)
-{
-	struct tidss_device *tidss = drmdev->dev_private;
-	struct wb_dev *wdev = tidss->wdev;
-
-	log_dbg(wdev, "Cleanup WB\n");
-
-	tidss_wbm2m_cleanup(wdev);
-}
-
diff --git a/drivers/gpu/drm/tidss/tidss_wb.h b/drivers/gpu/drm/tidss/tidss_wb.h
deleted file mode 100644
index 612a7660fadb..000000000000
--- a/drivers/gpu/drm/tidss/tidss_wb.h
+++ /dev/null
@@ -1,191 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2019 Texas Instruments Incorporated -  http://www.ti.com/
- * Author: Benoit Parrot <bparrot@ti.com>
- */
-
-#ifndef __TIDSS_WB_H__
-#define __TIDSS_WB_H__
-
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/mutex.h>
-#include <linux/wait.h>
-#include <linux/hrtimer.h>
-#include <drm/drmP.h>
-#include <drm/drm_atomic.h>
-#include <drm/drm_atomic_helper.h>
-#include <drm/drm_crtc.h>
-#include <drm/drm_crtc_helper.h>
-#include <drm/drm_fb_cma_helper.h>
-#include <drm/drm_fourcc.h>
-#include <drm/drm_gem_cma_helper.h>
-#include <drm/drm_plane_helper.h>
-
-#include <linux/videodev2.h>
-#include <media/v4l2-device.h>
-#include <media/v4l2-dev.h>
-#include <media/v4l2-ioctl.h>
-#include <media/v4l2-ctrls.h>
-#include <media/v4l2-event.h>
-#include <media/videobuf2-v4l2.h>
-#include <media/videobuf2-dma-contig.h>
-
-#include "tidss_irq.h"
-#include "tidss_dispc.h"
-//#include "tidss_dispc7.h"
-#include "tidss_drv.h"
-#include "tidss_plane.h"
-
-#define WB_MODULE_NAME "tidsswb"
-#define WBM2M_MODULE_NAME "tidss-m2m"
-
-extern unsigned int tidss_wbdebug;
-
-#define log_dbg(dev, fmt, arg...)	\
-		v4l2_dbg(1, tidss_wbdebug, &dev->v4l2_dev, "%s: " fmt, \
-			 __func__, ## arg)
-#define log_err(dev, fmt, arg...)	\
-		v4l2_err(&dev->v4l2_dev, fmt, ## arg)
-#define log_info(dev, fmt, arg...)	\
-		v4l2_info(&dev->v4l2_dev, fmt, ## arg)
-
-/* minimum and maximum frame sizes */
-#define MIN_W		2
-#define MIN_H		1
-#define MAX_W		4096
-#define MAX_H		4096
-
-/* required alignments */
-#define S_ALIGN		0	/* multiple of 1 */
-#define H_ALIGN		0	/* multiple of 2 */
-
-/* used as plane indices */
-#define MAX_PLANES	2
-#define LUMA_PLANE	0
-#define CHROMA_PLANE	1
-
-enum tidss_wb_mode {
-	TIDSS_WB_NOT_CONFIGURED = 0,
-	/* mem2mem from single ovl to wb */
-	TIDSS_WB_MEM2MEM_OVL = 1,
-	/* mem2mem from N overlays via single mgr to wb */
-	TIDSS_WB_MEM2MEM_MGR = 2,
-	/* capture from single mgr to wb */
-	TIDSS_WB_CAPTURE_MGR = 3
-};
-
-enum tidss_wb_state {
-	WB_STATE_NONE = 0,
-	WB_STATE_FIRST_FRAME,
-	WB_STATE_CAPTURING,
-	WB_STATE_STOPPING,
-	WB_STATE_STOPPED,
-};
-
-/* driver info for each of the supported video formats */
-struct wb_fmt {
-	u32	fourcc;			/* standard format identifier */
-	u8	coplanar;		/* set for unpacked Luma and Chroma */
-	u8	depth[MAX_PLANES];	/* Bits per pixel per plane*/
-};
-
-extern const struct wb_fmt tidss_wb_formats[];
-extern const unsigned int tidss_num_wb_formats;
-
-struct wb_buffer {
-	struct vb2_v4l2_buffer	vb;
-	struct list_head	list;
-};
-
-/*
- * per-queue, driver-specific private data.
- * MEM-2-MEM: Source: V4L2_BUF_TYPE_VIDEO_OUTPUT*
- *            Destination: V4L2_BUF_TYPE_VIDEO_CAPTURE*
- * CAPTURE:   Destination: V4L2_BUF_TYPE_VIDEO_CAPTURE* only
- */
-struct wb_q_data {
-	/* format info */
-	struct v4l2_format	format;
-	/* crop/compose rectangle */
-	struct v4l2_rect	c_rect;
-	/* format info */
-	const struct wb_fmt	*fmt;
-};
-
-enum {
-	Q_DATA_SRC = 0,
-	Q_DATA_DST = 1,
-};
-
-/* find our format description corresponding to the passed v4l2_format */
-const struct wb_fmt *tidss_wb_find_format(struct v4l2_format *f);
-const struct wb_fmt *__tidss_wb_find_format(u32 fourcc);
-
-struct wb_dev {
-	struct v4l2_device	v4l2_dev;
-	struct drm_device	*drm_dev;
-
-	atomic_t		irq_enabled;
-
-	/* v4l2_ioctl mutex */
-	struct mutex		lock;
-
-	enum tidss_wb_mode	mode;
-	struct wbm2m_dev	*m2m;
-};
-
-/*
- * there is one wbm2m_dev structure in the driver.
- */
-struct wbm2m_dev {
-	struct v4l2_device	v4l2_dev;
-	struct video_device	vfd;
-	struct v4l2_m2m_dev	*m2m_dev;
-	struct wb_dev		*dev;
-	struct drm_plane	*plane;
-
-	/* v4l2 buffers lock */
-	spinlock_t		lock;
-
-	struct vb2_alloc_ctx	*alloc_ctx;
-};
-
-/*
- * There is one wbm2m_ctx structure for each m2m context.
- */
-struct wbm2m_ctx {
-	struct v4l2_fh		fh;
-	struct wbm2m_dev	*dev;
-	struct v4l2_ctrl_handler hdl;
-
-	/* current frame seq */
-	unsigned int		sequence;
-	/* abort after next irq */
-	unsigned int		aborting;
-
-	/* src & dst queue data */
-	struct wb_q_data	q_data[2];
-
-	/* src & dst state data */
-	struct drm_plane_state s_state;
-	struct drm_framebuffer s_fb;
-	struct drm_gem_cma_object s_cma_gem_obj[2];
-
-	struct drm_plane_state d_state;
-	struct drm_framebuffer d_fb;
-	struct drm_gem_cma_object d_cma_gem_obj[2];
-};
-
-static inline struct wb_buffer *to_wb_buffer(struct vb2_buffer *vb2)
-{
-	return container_of(vb2, struct wb_buffer, vb.vb2_buf);
-}
-
-int tidss_wb_fourcc_v4l2_to_drm(u32 fourcc);
-
-void tidss_wbm2m_irq(struct wbm2m_dev *dev, u64 irqstatus);
-int tidss_wbm2m_init(struct wb_dev *dev);
-void tidss_wbm2m_cleanup(struct wb_dev *dev);
-
-#endif /* __TIDSS_WB_H__ */
diff --git a/drivers/gpu/drm/tidss/tidss_wb_m2m.c b/drivers/gpu/drm/tidss/tidss_wb_m2m.c
index 8cba4ccf266f..3001f7df1683 100644
--- a/drivers/gpu/drm/tidss/tidss_wb_m2m.c
+++ b/drivers/gpu/drm/tidss/tidss_wb_m2m.c
@@ -5,7 +5,7 @@
  *
  * Based on the virtual v4l2-mem2mem example device
  */
-
+#define DEBUG 1
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
-- 
2.17.1

